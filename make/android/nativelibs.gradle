/*
 * Native libs basic functionality
 *
 */

def getListProperty(name, defvalue) {
  def prop = localProperties.getProperty(name, defvalue)
  return prop.split()
}

def getSplittedAbiFilters() {
  return getListProperty('flavors.splitted.abifilters', '')
}

def getFatAbiFilters() {
  return getListProperty('flavors.fat.abifilters', '')
}

def getAabAbiFilters() {
  return getListProperty('flavors.thin.abifilters', '')
}

android {
    // required for stripping
    ndkVersion localProperties.getProperty("ndk.version", "")
    // store debug symbols in bundle
    defaultConfig.ndk.debugSymbolLevel 'FULL'
}

android {
    flavorDimensions 'packaging'

    splits.abi {
        def abis = getSplittedAbiFilters()
        reset()
        if (abis.length != 0) {
            enable true
            include abis
        }
    }

    productFlavors.whenObjectAdded { flavor ->
        flavor.ext.set('isBundle', false)
    }

    // Splits config is global and cannot be per-variant
    // so, it conflicts with another flavors due to non-empty ndk.abiFilters
    productFlavors {
        // Single APK
        fat {
            dimension 'packaging'
            versionNameSuffix '-fat'
            ndk.abiFilters getFatAbiFilters()
            signingConfig signingConfigs.release
        }

        // Single AAB
        aabStores.each { name -> 
          create("${name}") {
            dimension 'packaging'
            versionNameSuffix "-${name}"
            ndk.abiFilters getAabAbiFilters()
            signingConfig signingConfigs.getByName("aab_${name}")
            isBundle = true
          }
        }

        // Several APKs
        // Should not be combined with another flavors (configs)
        splitted {
            dimension 'packaging'
            versionNameSuffix '-splitted'
            signingConfig signingConfigs.release
        }
    }

    variantFilter { variant ->
        def isRelease = variant.buildType.name == 'release'
        def pkgFlavor = variant.flavors[0]
        assert pkgFlavor.dimension == 'packaging'
        def packaging = pkgFlavor.name
        if (!isRelease && packaging != 'fat') {
            setIgnore(true)
            println "Disable ${variant.name} for developer builds"
            return
        }
        if (splits.abi.enable != (packaging == 'splitted')) {
            setIgnore(true)
            println "Disable ${variant.name} due to abi splits"
            return
        }
        if (!splits.abi.enable && pkgFlavor.ndk.abiFilters.flatten().isEmpty()) {
            setIgnore(true)
            println "Disable ${variant.name} due to empty ndk.abiFilters"
            return
        }
    }
}

def callMake(cmdline) {
    def fullCmd = "make platform=android ${cmdline}"
    def proc = fullCmd.execute()
    proc.consumeProcessOutput(System.out, System.out)
    assert 0 == proc.waitFor()
}

android {
    def jniIntermediateDir = "${project.buildDir}/jni"
    sourceSets {
        main {
            jniLibs.srcDirs = [jniIntermediateDir]
        }
    }

    def nativeLibsTask = task("nativeLibs", group: "Native") {
        //optimize incremental builds - assume existing soFolder means that all libs are ready
        def outDir = jniIntermediateDir
        outputs.dir outDir
        doLast {
            def cpuCount = Runtime.runtime.availableProcessors()
            def allAbis = [applicationVariants*.productFlavors*.ndk.abiFilters, splits.abiFilters].flatten().unique()
            android.sourceSets.main.jni.srcDirs.each { jniDir ->
                callMake("multiarch=${allAbis.join(':')} bins_dir=${outDir} -C ${jniDir} -j ${cpuCount}")
            }
        }
    }

    applicationVariants.all { variant ->
        def suffix = variant.name.capitalize()
        tasks.getByName("package${suffix}").dependsOn.add(nativeLibsTask)
        tasks.getByName("merge${suffix}JniLibFolders").dependsOn.add(nativeLibsTask)
    }
}
